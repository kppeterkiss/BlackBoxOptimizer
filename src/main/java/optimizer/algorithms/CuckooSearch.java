package optimizer.algorithms;

import optimizer.common.InternalStateBase;
import optimizer.common.Solution;
import optimizer.param.Param;
import optimizer.trial.IterationResult;

import java.lang.Math;
import java.util.*;


public class CuckooSearch extends AbstractAlgorithm {
    InternalState state = new InternalState();
    Random rand = new Random();

    {
        this.parallelizable = ParallelExecution.GENERATION;
        this.iterationCounterCorrection = 2;
        this.optimizerParams = new LinkedList<>();
        this.optimizerParams.add(new Param(25,Integer.MAX_VALUE,1,"number_of_nests"));
        // discovery rate of cockoo eggs/solutions
        this.optimizerParams.add(new Param(0.25, 1,0, "Pa"));
        // beta
        this.optimizerParams.add(new Param(1.5, 2,1, "beta"));
        // In most cases, we can use α = O(L/10), where L is the
        //characteristic scale of the problem of interest, whereas in some cases α = O(L/100)
        this.optimizerParams.add(new Param(0.1, 100,0, "alpha"));
        this.optimizerParams.add(new Param(1, 100,0, "random_walk_step_size"));
    }

    private void initSearchSpace(List<Param> parameterMap){
        state.initSearchSpace(parameterMap);
        state.swarmBestNest = -1;
    }

    private void initNests(int swarmSize) {
        state.calculateResultsForIds = new LinkedList<>();
        //initialize the nests, and add to nest array
        for (int i = 0; i < swarmSize; ++i) {
            state.swarm.add(new Solution(
                    state.dimension,
                    state.lowerBounds,
                    state.upperBounds,
                    rand));
        }
    }

    @Override
    public void updateParameters(List<Param> parameterMap, List<IterationResult> landscape) {
        int numberOfNests = ((Number)optimizerParams.get(0).getValue()).intValue();
        double beta = ((Number)optimizerParams.get(2).getValue()).floatValue();
        double alpha = ((Number)optimizerParams.get(3).getValue()).floatValue();
        switch (state.phase) {
            case init:
                initSearchSpace(parameterMap);
                initNests(numberOfNests);
                break;
            case first_part:
                /*
                Get a cuckoo randomly
                Generate a solution by L´evy flights [e.g., Eq.(9.2)]
                Evaluate its solution quality or objective value fi
                */
                for (int j = 0; j < numberOfNests; ++j) {
                    //The best solution does not change
                    if (state.swarmBestNest != j) {
                        getNest(j).levy_flights(beta,alpha, rand, state.swarmBestKnownPosition);
                        getNest(j).checkBoundsForNewPosition(state.dimension, state.lowerBounds, state.upperBounds);
                        state.calculateResultsForIds.add(j);
                    }
                }
                break;
            case second_part:
                float Pa = ((Number)optimizerParams.get(1).getValue()).floatValue();
                float randWalkStepSize = ((Number)optimizerParams.get(4).getValue()).floatValue();
                /*
                A fraction (pa) of worse nests are abandoned
                New nests/solutions are built/generated by Eq.(9.1)
                Keep best solutions (or nests with quality solutions)
                Rank the solutions and find the current best
                */
                for (int i = 0; i < numberOfNests; ++i) {
                    int j = rand.nextInt(state.swarm.size());
                    int k = rand.nextInt(state.swarm.size());
                    float epsilon = rand.nextFloat();

                    if (state.swarmBestNest != i) {
                        for (int dim = 0; dim < state.dimension; ++dim) {
                            getNest(i).newPosition[dim] =
                                    getNest(i).position[dim] + randWalkStepSize *
                                            (float) (alpha * ((Math.signum(Pa - epsilon) + 1) / 2) *  // Heaviside function
                                                    (getNest(j).position[dim] - getNest(k).position[dim]));
                        }
                        getNest(i).checkBoundsForNewPosition(state.dimension, state.lowerBounds, state.upperBounds);
                        state.calculateResultsForIds.add(i);
                    }
                }
                break;
        }
    }

    private List<Param> createParamSetup(List<Param> pattern, float[] input, int id) throws CloneNotSupportedException {
        List<Param> setup = Param.cloneParamList(pattern);
        // setup each dimension of the position
        for (int i = 0; i < setup.size(); ++i) {
            setup.get(i).setInitValue(input[i]);
            setup.get(i).setId(id);
        }
        return setup;
    }

    @Override
    public List<List<Param>> getParameterMapBatch(List<Param> pattern)throws CloneNotSupportedException {
        List<List<Param>> result = new LinkedList<>();
        switch (state.phase) {
            case init:
                for(int j = 0; j < state.swarm.size(); ++j) {
                    result.add(createParamSetup(pattern, getNest(j).newPosition, j));
                }
                break;
            case first_part:
            case second_part:
                for(int j = 0; j < state.calculateResultsForIds.size(); ++j) {
                    int id = state.calculateResultsForIds.get(j);
                    result.add(createParamSetup(pattern, getNest(id).newPosition,id));
                }
                break;
        }
        return result;
    }

    public void setResults(List<IterationResult> results) throws CloneNotSupportedException {
        for (IterationResult res : results) {
            Solution nest = getNest(res.getConfiguration().get(0).getId());
            nest.saveResultAndPosition(res);
            if(nest.actualFitness.betterThan(state.swarmBestFitness)) {
                state.swarmBestFitness = nest.actualFitness;
                state.swarmBestKnownPosition = nest.position.clone();
                state.swarmBestNest = res.getConfiguration().get(0).getId();
            }
        }
    }

    public void updateGlobals() {
        switch (state.phase) {
            case init:
            case second_part:
                state.phase = AlgorithmPhase.first_part;
                break;
            case first_part:
                state.phase = AlgorithmPhase.second_part;
                break;
        }
        state.calculateResultsForIds.clear();
    }

    private Solution getNest(int id) {
        return state.swarm.get(id);
    }

    enum AlgorithmPhase {
            init,
            first_part,
            second_part
    }

    class InternalState extends InternalStateBase<Solution> {
        int swarmBestNest;
        List<Integer> calculateResultsForIds;
        AlgorithmPhase phase;

        public InternalState() {
            super();
            phase = AlgorithmPhase.init;
        }
    }
}
